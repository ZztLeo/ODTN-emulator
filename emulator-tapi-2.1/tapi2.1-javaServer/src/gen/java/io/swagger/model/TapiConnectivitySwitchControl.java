/*
 * tapi-common,tapi-dsr,tapi-path-computation,tapi-eth,tapi-virtual-network,tapi-topology,tapi-notification,tapi-oam,tapi-photonic-media,tapi-connectivity API
 * tapi-common,tapi-dsr,tapi-path-computation,tapi-eth,tapi-virtual-network,tapi-topology,tapi-notification,tapi-oam,tapi-photonic-media,tapi-connectivity API generated from yang definitions
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.model;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.model.TapiCommonGlobalClass;
import io.swagger.model.TapiCommonLayerProtocolName;
import io.swagger.model.TapiCommonNameAndValue;
import io.swagger.model.TapiConnectivityCoordinateType;
import io.swagger.model.TapiConnectivityResilienceConstraint;
import io.swagger.model.TapiConnectivityReversionMode;
import io.swagger.model.TapiConnectivitySwitch;
import io.swagger.model.TapiConnectivitySwitchControlRef;
import io.swagger.model.TapiTopologyResilienceType;
import java.util.ArrayList;
import java.util.List;
import javax.validation.constraints.*;

/**
 * TapiConnectivitySwitchControl
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaJerseyServerCodegen", date = "2018-11-14T14:58:12.974+01:00")
public class TapiConnectivitySwitchControl   {
  @JsonProperty("name")
  private List<TapiCommonNameAndValue> name = null;

  @JsonProperty("uuid")
  private String uuid = null;

  @JsonProperty("is-lock-out")
  private Boolean isLockOut = false;

  @JsonProperty("max-switch-times")
  private Integer maxSwitchTimes = null;

  @JsonProperty("restoration-coordinate-type")
  private TapiConnectivityCoordinateType restorationCoordinateType = null;

  @JsonProperty("is-coordinated-switching-both-ends")
  private Boolean isCoordinatedSwitchingBothEnds = false;

  @JsonProperty("hold-off-time")
  private Integer holdOffTime = null;

  @JsonProperty("is-frozen")
  private Boolean isFrozen = false;

  @JsonProperty("wait-to-revert-time")
  private Integer waitToRevertTime = 15;

  @JsonProperty("resilience-type")
  private TapiTopologyResilienceType resilienceType = null;

  @JsonProperty("preferred-restoration-layer")
  private List<TapiCommonLayerProtocolName> preferredRestorationLayer = null;

  @JsonProperty("restore-priority")
  private Integer restorePriority = null;

  @JsonProperty("reversion-mode")
  private TapiConnectivityReversionMode reversionMode = null;

  @JsonProperty("sub-switch-control")
  private List<TapiConnectivitySwitchControlRef> subSwitchControl = null;

  @JsonProperty("switch")
  private List<TapiConnectivitySwitch> _switch = null;

  public TapiConnectivitySwitchControl name(List<TapiCommonNameAndValue> name) {
    this.name = name;
    return this;
  }

  public TapiConnectivitySwitchControl addNameItem(TapiCommonNameAndValue nameItem) {
    if (this.name == null) {
      this.name = new ArrayList<TapiCommonNameAndValue>();
    }
    this.name.add(nameItem);
    return this;
  }

  /**
   * List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity.
   * @return name
   **/
  @JsonProperty("name")
  @ApiModelProperty(value = "List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity.")
  public List<TapiCommonNameAndValue> getName() {
    return name;
  }

  public void setName(List<TapiCommonNameAndValue> name) {
    this.name = name;
  }

  public TapiConnectivitySwitchControl uuid(String uuid) {
    this.uuid = uuid;
    return this;
  }

  /**
   * UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.                      UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.                      Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-&#39; + &#39;[0-9a-fA-F]{4}-[0-9a-fA-F]{12}                       Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6
   * @return uuid
   **/
  @JsonProperty("uuid")
  @ApiModelProperty(value = "UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.                      UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.                      Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}                       Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6")
  public String getUuid() {
    return uuid;
  }

  public void setUuid(String uuid) {
    this.uuid = uuid;
  }

  public TapiConnectivitySwitchControl isLockOut(Boolean isLockOut) {
    this.isLockOut = isLockOut;
    return this;
  }

  /**
   * The resource is configured to temporarily not be available for use in the protection scheme(s) it is part of.                      This overrides all other protection control states including forced.                      If the item is locked out then it cannot be used under any circumstances.                      Note: Only relevant when part of a protection scheme.
   * @return isLockOut
   **/
  @JsonProperty("is-lock-out")
  @ApiModelProperty(value = "The resource is configured to temporarily not be available for use in the protection scheme(s) it is part of.                      This overrides all other protection control states including forced.                      If the item is locked out then it cannot be used under any circumstances.                      Note: Only relevant when part of a protection scheme.")
  public Boolean isIsLockOut() {
    return isLockOut;
  }

  public void setIsLockOut(Boolean isLockOut) {
    this.isLockOut = isLockOut;
  }

  public TapiConnectivitySwitchControl maxSwitchTimes(Integer maxSwitchTimes) {
    this.maxSwitchTimes = maxSwitchTimes;
    return this;
  }

  /**
   * Used to limit the maximum swtich times. When work fault disappears , and traffic return to the original work path, switch counter reset.
   * @return maxSwitchTimes
   **/
  @JsonProperty("max-switch-times")
  @ApiModelProperty(value = "Used to limit the maximum swtich times. When work fault disappears , and traffic return to the original work path, switch counter reset.")
  public Integer getMaxSwitchTimes() {
    return maxSwitchTimes;
  }

  public void setMaxSwitchTimes(Integer maxSwitchTimes) {
    this.maxSwitchTimes = maxSwitchTimes;
  }

  public TapiConnectivitySwitchControl restorationCoordinateType(TapiConnectivityCoordinateType restorationCoordinateType) {
    this.restorationCoordinateType = restorationCoordinateType;
    return this;
  }

  /**
   *  The coordination mechanism between multi-layers.
   * @return restorationCoordinateType
   **/
  @JsonProperty("restoration-coordinate-type")
  @ApiModelProperty(value = " The coordination mechanism between multi-layers.")
  public TapiConnectivityCoordinateType getRestorationCoordinateType() {
    return restorationCoordinateType;
  }

  public void setRestorationCoordinateType(TapiConnectivityCoordinateType restorationCoordinateType) {
    this.restorationCoordinateType = restorationCoordinateType;
  }

  public TapiConnectivitySwitchControl isCoordinatedSwitchingBothEnds(Boolean isCoordinatedSwitchingBothEnds) {
    this.isCoordinatedSwitchingBothEnds = isCoordinatedSwitchingBothEnds;
    return this;
  }

  /**
   * Is operating such that switching at both ends of each flow acorss the FC is coordinated at both ingress and egress ends.
   * @return isCoordinatedSwitchingBothEnds
   **/
  @JsonProperty("is-coordinated-switching-both-ends")
  @ApiModelProperty(value = "Is operating such that switching at both ends of each flow acorss the FC is coordinated at both ingress and egress ends.")
  public Boolean isIsCoordinatedSwitchingBothEnds() {
    return isCoordinatedSwitchingBothEnds;
  }

  public void setIsCoordinatedSwitchingBothEnds(Boolean isCoordinatedSwitchingBothEnds) {
    this.isCoordinatedSwitchingBothEnds = isCoordinatedSwitchingBothEnds;
  }

  public TapiConnectivitySwitchControl holdOffTime(Integer holdOffTime) {
    this.holdOffTime = holdOffTime;
    return this;
  }

  /**
   * This attribute indicates the time, in milliseconds, between declaration of signal degrade or signal fail, and the initialization of the protection switching algorithm.
   * @return holdOffTime
   **/
  @JsonProperty("hold-off-time")
  @ApiModelProperty(value = "This attribute indicates the time, in milliseconds, between declaration of signal degrade or signal fail, and the initialization of the protection switching algorithm.")
  public Integer getHoldOffTime() {
    return holdOffTime;
  }

  public void setHoldOffTime(Integer holdOffTime) {
    this.holdOffTime = holdOffTime;
  }

  public TapiConnectivitySwitchControl isFrozen(Boolean isFrozen) {
    this.isFrozen = isFrozen;
    return this;
  }

  /**
   * Temporarily prevents any switch action to be taken and, as such, freezes the current state.                       Until the freeze is cleared, additional near-end external commands are rejected and fault condition changes and received APS messages are ignored.                      All administrative controls of any aspect of protection are rejected.
   * @return isFrozen
   **/
  @JsonProperty("is-frozen")
  @ApiModelProperty(value = "Temporarily prevents any switch action to be taken and, as such, freezes the current state.                       Until the freeze is cleared, additional near-end external commands are rejected and fault condition changes and received APS messages are ignored.                      All administrative controls of any aspect of protection are rejected.")
  public Boolean isIsFrozen() {
    return isFrozen;
  }

  public void setIsFrozen(Boolean isFrozen) {
    this.isFrozen = isFrozen;
  }

  public TapiConnectivitySwitchControl waitToRevertTime(Integer waitToRevertTime) {
    this.waitToRevertTime = waitToRevertTime;
    return this;
  }

  /**
   * If the protection system is revertive, this attribute specifies the time, in minutes, to wait after a fault clears on a higher priority (preferred) resource before reverting to the preferred resource.
   * @return waitToRevertTime
   **/
  @JsonProperty("wait-to-revert-time")
  @ApiModelProperty(value = "If the protection system is revertive, this attribute specifies the time, in minutes, to wait after a fault clears on a higher priority (preferred) resource before reverting to the preferred resource.")
  public Integer getWaitToRevertTime() {
    return waitToRevertTime;
  }

  public void setWaitToRevertTime(Integer waitToRevertTime) {
    this.waitToRevertTime = waitToRevertTime;
  }

  public TapiConnectivitySwitchControl resilienceType(TapiTopologyResilienceType resilienceType) {
    this.resilienceType = resilienceType;
    return this;
  }

  /**
   * none
   * @return resilienceType
   **/
  @JsonProperty("resilience-type")
  @ApiModelProperty(value = "none")
  public TapiTopologyResilienceType getResilienceType() {
    return resilienceType;
  }

  public void setResilienceType(TapiTopologyResilienceType resilienceType) {
    this.resilienceType = resilienceType;
  }

  public TapiConnectivitySwitchControl preferredRestorationLayer(List<TapiCommonLayerProtocolName> preferredRestorationLayer) {
    this.preferredRestorationLayer = preferredRestorationLayer;
    return this;
  }

  public TapiConnectivitySwitchControl addPreferredRestorationLayerItem(TapiCommonLayerProtocolName preferredRestorationLayerItem) {
    if (this.preferredRestorationLayer == null) {
      this.preferredRestorationLayer = new ArrayList<TapiCommonLayerProtocolName>();
    }
    this.preferredRestorationLayer.add(preferredRestorationLayerItem);
    return this;
  }

  /**
   * Indicate which layer this resilience parameters package configured for.
   * @return preferredRestorationLayer
   **/
  @JsonProperty("preferred-restoration-layer")
  @ApiModelProperty(value = "Indicate which layer this resilience parameters package configured for.")
  public List<TapiCommonLayerProtocolName> getPreferredRestorationLayer() {
    return preferredRestorationLayer;
  }

  public void setPreferredRestorationLayer(List<TapiCommonLayerProtocolName> preferredRestorationLayer) {
    this.preferredRestorationLayer = preferredRestorationLayer;
  }

  public TapiConnectivitySwitchControl restorePriority(Integer restorePriority) {
    this.restorePriority = restorePriority;
    return this;
  }

  /**
   * none
   * @return restorePriority
   **/
  @JsonProperty("restore-priority")
  @ApiModelProperty(value = "none")
  public Integer getRestorePriority() {
    return restorePriority;
  }

  public void setRestorePriority(Integer restorePriority) {
    this.restorePriority = restorePriority;
  }

  public TapiConnectivitySwitchControl reversionMode(TapiConnectivityReversionMode reversionMode) {
    this.reversionMode = reversionMode;
    return this;
  }

  /**
   * Indcates whether the protection scheme is revertive or non-revertive.
   * @return reversionMode
   **/
  @JsonProperty("reversion-mode")
  @ApiModelProperty(value = "Indcates whether the protection scheme is revertive or non-revertive.")
  public TapiConnectivityReversionMode getReversionMode() {
    return reversionMode;
  }

  public void setReversionMode(TapiConnectivityReversionMode reversionMode) {
    this.reversionMode = reversionMode;
  }

  public TapiConnectivitySwitchControl subSwitchControl(List<TapiConnectivitySwitchControlRef> subSwitchControl) {
    this.subSwitchControl = subSwitchControl;
    return this;
  }

  public TapiConnectivitySwitchControl addSubSwitchControlItem(TapiConnectivitySwitchControlRef subSwitchControlItem) {
    if (this.subSwitchControl == null) {
      this.subSwitchControl = new ArrayList<TapiConnectivitySwitchControlRef>();
    }
    this.subSwitchControl.add(subSwitchControlItem);
    return this;
  }

  /**
   * none
   * @return subSwitchControl
   **/
  @JsonProperty("sub-switch-control")
  @ApiModelProperty(value = "none")
  public List<TapiConnectivitySwitchControlRef> getSubSwitchControl() {
    return subSwitchControl;
  }

  public void setSubSwitchControl(List<TapiConnectivitySwitchControlRef> subSwitchControl) {
    this.subSwitchControl = subSwitchControl;
  }

  public TapiConnectivitySwitchControl _switch(List<TapiConnectivitySwitch> _switch) {
    this._switch = _switch;
    return this;
  }

  public TapiConnectivitySwitchControl addSwitchItem(TapiConnectivitySwitch _switchItem) {
    if (this._switch == null) {
      this._switch = new ArrayList<TapiConnectivitySwitch>();
    }
    this._switch.add(_switchItem);
    return this;
  }

  /**
   * none
   * @return _switch
   **/
  @JsonProperty("switch")
  @ApiModelProperty(value = "none")
  public List<TapiConnectivitySwitch> getSwitch() {
    return _switch;
  }

  public void setSwitch(List<TapiConnectivitySwitch> _switch) {
    this._switch = _switch;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TapiConnectivitySwitchControl tapiConnectivitySwitchControl = (TapiConnectivitySwitchControl) o;
    return Objects.equals(this.name, tapiConnectivitySwitchControl.name) &&
        Objects.equals(this.uuid, tapiConnectivitySwitchControl.uuid) &&
        Objects.equals(this.isLockOut, tapiConnectivitySwitchControl.isLockOut) &&
        Objects.equals(this.maxSwitchTimes, tapiConnectivitySwitchControl.maxSwitchTimes) &&
        Objects.equals(this.restorationCoordinateType, tapiConnectivitySwitchControl.restorationCoordinateType) &&
        Objects.equals(this.isCoordinatedSwitchingBothEnds, tapiConnectivitySwitchControl.isCoordinatedSwitchingBothEnds) &&
        Objects.equals(this.holdOffTime, tapiConnectivitySwitchControl.holdOffTime) &&
        Objects.equals(this.isFrozen, tapiConnectivitySwitchControl.isFrozen) &&
        Objects.equals(this.waitToRevertTime, tapiConnectivitySwitchControl.waitToRevertTime) &&
        Objects.equals(this.resilienceType, tapiConnectivitySwitchControl.resilienceType) &&
        Objects.equals(this.preferredRestorationLayer, tapiConnectivitySwitchControl.preferredRestorationLayer) &&
        Objects.equals(this.restorePriority, tapiConnectivitySwitchControl.restorePriority) &&
        Objects.equals(this.reversionMode, tapiConnectivitySwitchControl.reversionMode) &&
        Objects.equals(this.subSwitchControl, tapiConnectivitySwitchControl.subSwitchControl) &&
        Objects.equals(this._switch, tapiConnectivitySwitchControl._switch);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, uuid, isLockOut, maxSwitchTimes, restorationCoordinateType, isCoordinatedSwitchingBothEnds, holdOffTime, isFrozen, waitToRevertTime, resilienceType, preferredRestorationLayer, restorePriority, reversionMode, subSwitchControl, _switch);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TapiConnectivitySwitchControl {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("    isLockOut: ").append(toIndentedString(isLockOut)).append("\n");
    sb.append("    maxSwitchTimes: ").append(toIndentedString(maxSwitchTimes)).append("\n");
    sb.append("    restorationCoordinateType: ").append(toIndentedString(restorationCoordinateType)).append("\n");
    sb.append("    isCoordinatedSwitchingBothEnds: ").append(toIndentedString(isCoordinatedSwitchingBothEnds)).append("\n");
    sb.append("    holdOffTime: ").append(toIndentedString(holdOffTime)).append("\n");
    sb.append("    isFrozen: ").append(toIndentedString(isFrozen)).append("\n");
    sb.append("    waitToRevertTime: ").append(toIndentedString(waitToRevertTime)).append("\n");
    sb.append("    resilienceType: ").append(toIndentedString(resilienceType)).append("\n");
    sb.append("    preferredRestorationLayer: ").append(toIndentedString(preferredRestorationLayer)).append("\n");
    sb.append("    restorePriority: ").append(toIndentedString(restorePriority)).append("\n");
    sb.append("    reversionMode: ").append(toIndentedString(reversionMode)).append("\n");
    sb.append("    subSwitchControl: ").append(toIndentedString(subSwitchControl)).append("\n");
    sb.append("    _switch: ").append(toIndentedString(_switch)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

